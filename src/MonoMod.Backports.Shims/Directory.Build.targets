<?xml version="1.0" encoding="utf-8" ?>
<Project>

  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.targets', '$(MSBuildThisFileDirectory)../'))" />

  <ItemGroup>
    <ProjectReference Include="$(MMSourcePath)ShimGen\ShimGen.csproj"
                      Reference="false" ReferenceOutputAssembly="false"
                      OutputItemType="MMShimGen"
                      Private="false" Pack="false"
                      SetTargetFramework="TargetFramework=net9.0"
                      SkipGetTargetFrameworkProperties="true" />
  </ItemGroup>

  <ItemDefinitionGroup>
    <PackageReference>
      <Shim>false</Shim>
    </PackageReference>
  </ItemDefinitionGroup>

  <PropertyGroup>
    <_ShimsDir>$(IntermediateOutputPath)shims/</_ShimsDir>
    <_OutputTfmsTxt>$(IntermediateOutputPath)tfms.txt</_OutputTfmsTxt>
  </PropertyGroup>

  <Target Name="_ConfigureShimmedPackageRefs"
          BeforeTargets="CollectPackageReferences">
    <ItemGroup>
      <PackageReference Update="@(PackageReference)" Condition="'%(Shim)' == 'true'">
        <PrivateAssets>none</PrivateAssets>
        <Pack>false</Pack>
        <GeneratePathProperty>true</GeneratePathProperty>
      </PackageReference>
    </ItemGroup>
  </Target>
  
  <Target Name="_GetShimmedPackages"
          DependsOnTargets="_ConfigureShimmedPackageRefs">
    <ItemGroup>
      <_ShimmedPackages Include="@(PackageReference)" Condition="'%(Shim)' == 'true'">
        <PkgProp>Pkg$([System.String]::Copy('%(Identity)').Replace('.','_'))</PkgProp>
      </_ShimmedPackages>
    </ItemGroup>
    <ItemGroup>
      <_ShimmedPackages>
        <PkgPath>$(%(PkgProp))</PkgPath>
      </_ShimmedPackages>
    </ItemGroup>
  </Target>

  <Target Name="BuildShims"
          BeforeTargets="CoreCompile"
          DependsOnTargets="$(CoreCompileDependsOn);_GetShimmedPackages;ResolveProjectReferences"
          Inputs="$(MSBuildAllProjects);@(MMShimGen)"
          Outputs="$(_OutputTfmsTxt)"
          Condition="'$(dotnet-nugetize)' == ''"
          >

    <ItemGroup>
      <_ExistingShimFiles Include="$(_ShimsDir)**/*" />
    </ItemGroup>
    
    <Delete Files="@(_ExistingShimFiles)" Condition="Exists('$(_ShimsDir)')" />
    <MakeDir Directories="$(_ShimsDir)" Condition="!Exists('$(_ShimsDir)')"  />

    <PropertyGroup>
      <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and '$(OS)' == 'Windows_NT'">.exe</_NativeExecutableExtension>
      <_ShimGenExe>%(MMShimGen.RelativeDir)%(FileName)$(_NativeExecutableExtension)</_ShimGenExe>
      <_SnkDir>$(MMRootPath)snk/</_SnkDir>
    </PropertyGroup>

    <ItemGroup>
      <_PPArguments Remove="@(_PPArguments)" />
      <_PPArguments Include="$(_ShimsDir)" /> <!-- 1: the output directory -->
      <_PPArguments Include="$(_SnkDir)" /> <!-- 2: snk directory -->
      <!-- 3: the paths to the packages to process -->
      <_PPArguments Include="%(_ShimmedPackages.PkgPath)" />
    </ItemGroup>

    <Exec ConsoleToMsBuild="true" LogStandardErrorAsError="true"
      Command="&quot;$(_ShimgenExe)&quot; @(_PPArguments->'&quot;%(Identity)&quot;',' ')">
      <Output TaskParameter="ExitCode" PropertyName="_ExitCode" />
      <Output TaskParameter="ConsoleOutput" ItemName="_ShimGenOutput" />
    </Exec>

    <ItemGroup>
      <_ShimFiles Include="$(_ShimsDir)**/*.dll" />
      <FileWrites Include="@(_ShimFiles)" />

      <IntermediateAssembly Remove="@(IntermediateAssembly)" />
      <!--<IntermediateAssembly Include="@(_PatchedFiles)" />-->
      <_DebugSymbolsIntermediatePath Remove="@(_DebugSymbolsIntermediatePath)" />
      <_ShimFiles Include="$(_ShimsDir)**/*.pdb" />
      <DocFileItem Remove="@(DocFileItem)" />
      <_ShimFiles Include="$(_ShimsDir)*.xml" />
    </ItemGroup>

    <Error Text="ShimGen failed" Condition="'$(_ExitCode)' != '0'" />
    
    <!-- Locate the TFMs to generate in the package -->
    <ItemGroup>
      <_TfmDirs Include="$([System.String]::Copy('%(_ShimGenOutput.Identity)').Replace('tfm:', ''))"
                Condition="$([System.String]::Copy('%(_ShimGenOutput.Identity)').StartsWith('tfm:'))" />
    </ItemGroup>
    
    <!-- Then we'll write the target tfms to a file, which will later be read and use to construct the package -->
    <WriteLinesToFile File="$(_OutputTfmsTxt)" Lines="@(_TfmDirs)" WriteOnlyWhenDifferent="false" Overwrite="true" />
  </Target>

  <Target Name="_CopyShimsToOutputRecursive"
          DependsOnTargets="BuildShims"
          BeforeTargets="CopyFilesToOutputDirectory"
          Inputs="@(_ShimFiles)"
          Outputs="@(_ShimFiles->'$(OutDir)%(RecursiveDir)%(Filename)%(Extension)'">
    <Copy SourceFiles="@(_ShimFiles)" DestinationFolder="$(OutDir)%(RecursiveDir)" />
  </Target>
  
  <!-- Packaging stuff -->
  
  <Target Name="_SetUpShimPackagePaths"
          DependsOnTargets="BuildShims">

    <ItemGroup>
      <PackageFile Include="%(_ShimFiles.Identity)"
                   TargetFramework="$([System.IO.Path]::GetFileName($([System.IO.Path]::GetDirectoryName('%(_ShimFiles.RecursiveDir)'))))"
                   PackFolder="lib" />
    </ItemGroup>

    <!-- Make sure all output TFMs have a dummy  -->
    <ItemGroup>
      <_PackageMinTfms Include="$(PackageMinTfms)" />
    </ItemGroup>
    <PropertyGroup>
      <_TfmsWithFiles>@(PackageFile->'%(TargetFramework)')</_TfmsWithFiles>
    </PropertyGroup>
    <ItemGroup>
      <_PackageMinTfms Include="@(PackageFile->'%(TargetFramework)')" />
    </ItemGroup>

    <MakeDir Directories="@(_PackageMinTfms->'$(IntermediateOutputPath)%(Identity)')" ContinueOnError="true" />
    <WriteLinesToFile File="$(IntermediateOutputPath)%(_PackageMinTfms.Identity)\_._" Overwrite="true" ContinueOnError="true" />
    
    <ItemGroup>
      <PackageFile Include="$(IntermediateOutputPath)%(_PackageMinTfms.Identity)\_._"
                   TargetFramework="%(_PackageMinTfms.Identity)"
                   PackFolder="lib"
                   Condition="!$([System.String]::Copy('$(_TfmsWithFiles)').Contains('%(_PackageMinTfms.Identity)'))" />
    </ItemGroup>

  </Target>

  <Target Name="_BuildPackageConflictOverrides" DependsOnTargets="_GetShimmedPackages">
    <PropertyGroup>
      <_OverridePackages>@(_ShimmedPackages->'%(Identity)|%(Version)')</_OverridePackages>
      <_ImportedPropOpen><![CDATA[<$(PackageId.Replace('.','_'))_Imported>]]></_ImportedPropOpen>
      <_ImportedPropClose><![CDATA[</$(PackageId.Replace('.','_'))_Imported>]]></_ImportedPropClose>
      <_BuildFileContent>
        <Project>
          <PropertyGroup>
            $(_ImportedPropOpen)true$(_ImportedPropClose)
          </PropertyGroup>
          <ItemGroup Condition="'%24(DisableDefaultPackageConflictOverrides)' != 'true' and %24(DisableBackportsPackageConflictOverrides)' != 'true'">
            <PackageConflictOverrides Include="$(PackageId)">
              <OverriddenPackages>$(_OverridePackages)</OverriddenPackages>
            </PackageConflictOverrides>
          </ItemGroup>
        </Project>
      </_BuildFileContent>
      <_BuildTransitiveContent>
        <Project>
          <Import Project="%24(MSBuildThisFileDirectory)../build/$(PackageId).targets" Condition="'%24($(PackageId.Replace('.','_'))_Imported)' != 'true'" />
        </Project>
      </_BuildTransitiveContent>
      
    </PropertyGroup>

    <MakeDir Directories="$(IntermediateOutputPath)pkgBuild;$(IntermediateOutputPath)pkgBuildTransitive" />
    <WriteLinesToFile File="$(IntermediateOutputPath)pkgBuild/$(PackageId).targets" Overwrite="true" Lines="$([MSBuild]::Escape('$(_BuildFileContent)'))" />
    <WriteLinesToFile File="$(IntermediateOutputPath)pkgBuildTransitive/$(PackageId).targets" Overwrite="true" Lines="$([MSBuild]::Escape('$(_BuildTransitiveContent)'))" />

    <ItemGroup>
      <PackageFile Include="$(IntermediateOutputPath)pkgBuild/$(PackageId).targets"
                   PackFolder="build" />
      <PackageFile Include="$(IntermediateOutputPath)pkgBuildTransitive/$(PackageId).targets"
                   PackFolder="buildTransitive" />
    </ItemGroup>
    
  </Target>
  
  <!-- ApiCompat fixes -->
  
  <ItemGroup>
    <ProjectReference Include="$(MMSourcePath)GenApiCompatDll\GenApiCompatDll.csproj"
                      Reference="false" ReferenceOutputAssembly="false"
                      OutputItemType="MMGenApiCompat"
                      Private="false" Pack="false"
                      SetTargetFramework="TargetFramework=net9.0"
                      SkipGetTargetFrameworkProperties="true" />
  </ItemGroup>

  <PropertyGroup>
    <_DummyRestoreProjectDir>$(IntermediateOutputPath)dummy/</_DummyRestoreProjectDir>
    <_DummyRestoreProjectPath>$(_DummyRestoreProjectDir)dummy.csproj</_DummyRestoreProjectPath>
    <_DummyRestoreProjectTemplate>
      <Project Sdk="Microsoft.NET.Sdk">
        <PropertyGroup>
          <TargetFrameworks>{{TFMS}}</TargetFrameworks>
          <EnableDefaultItems>false</EnableDefaultItems>
          <CheckEolTargetFramework>false</CheckEolTargetFramework>
          <NuGetAudit>false</NuGetAudit>
        </PropertyGroup>
        <ItemGroup>
          <ProjectReference Include="$(MSBuildThisFileDirectory)../MonoMod.Backports/MonoMod.Backports.csproj" />
          {{PKGREF}}
        </ItemGroup>
      </Project>
    </_DummyRestoreProjectTemplate>

    <_DummyPackageReferenceTemplate>
      <PackageReference Include="{{PKGNAME}}" Version="{{PKGVER}}" Condition="{{TFMCOND}}" />
    </_DummyPackageReferenceTemplate>
    
    <_ApiCompatAsmOut>$(IntermediateOutputPath)apicompat/</_ApiCompatAsmOut>
    <_BackportsTfmsTxt>$(IntermediateOutputPath)backports_tfms.txt</_BackportsTfmsTxt>
  </PropertyGroup>

  <Target Name="_GetPackagesSupportedTfms" DependsOnTargets="_GetShimmedPackages" Outputs="|%(_ShimmedPackages.Identity)|">
    <PropertyGroup>
      <_PkgPath>%(_ShimmedPackages.PkgPath)</_PkgPath>
    </PropertyGroup>
    <ItemGroup>
      <_PkgLibFolderPaths Remove="@(_PkgLibFolders)" />
      <_PkgLibFolderPaths Include="$([System.IO.Directory]::GetDirectories('$(_PkgPath)/lib/'))" />
      <_PkgLibFolders Remove="@(_PkgLibFolders)" />
      <_PkgLibFolders Include="@(_PkgLibFolderPaths->'$([System.IO.Path]::GetFileName('%(_PkgLibFolderPaths.Identity)'))')" />
      <_PkgCond Remove="@(_PkgCond)" />
      <_PkgCond Include="%(_PkgLibFolders.Identity)">
        <TgtFwk>$([MSBuild]::GetTargetFrameworkIdentifier('%(_PkgLibFolders.Identity)'))</TgtFwk>
        <TgtVer>$([MSBuild]::GetTargetFrameworkVersion('%(_PkgLibFolders.Identity)'))</TgtVer>
      </_PkgCond>
      <_PkgCond>
        <Cond>
          (%24([MSBuild]::GetTargetFrameworkIdentifier('%24(TargetFramework)')) == '%(TgtFwk)'
          and %24([MSBuild]::VersionGreaterThanOrEquals(%24([MSBuild]::GetTargetFrameworkVersion('%24(TargetFramework)')),'%(TgtVer)')))
        </Cond>
      </_PkgCond>
    </ItemGroup>
    <PropertyGroup>
      <_PkgTfms>@(_PkgLibFolders)</_PkgTfms>
      <_PkgCond>@(_PkgCond->'%(Cond)',' or ')</_PkgCond>
    </PropertyGroup>
    <ItemGroup>
      <_ShimmedPackages Update="%(_ShimmedPackages.Identity)" Tfms="$(_PkgTfms)" TfmCond="$(_PkgCond)" />
    </ItemGroup>
  </Target>
  
  <Target Name="_FixReferencePathForValidate" DependsOnTargets="_SetUpShimPackagePaths;_GetPackagesSupportedTfms">
    
    <!-- Ask Backports for the list of TFMs to test against -->
    <MSBuild Projects="$(MSBuildThisFileDirectory)../MonoMod.Backports/MonoMod.Backports.csproj"
             Targets="GetProperties"
             Properties="PropertyNames=TargetFrameworks;BuildProjectReferences=false">
      <Output ItemName="_BackportsProps" TaskParameter="TargetOutputs" />
    </MSBuild>

    <PropertyGroup>
      <_BackportsTfms>@(_BackportsProps->'%(Value)')</_BackportsTfms>
    </PropertyGroup>
    <ItemGroup>
      <_BackportsTfms1 Include="$(_BackportsTfms)" />
      <_BackportsTfms1 Include="$(_TfmsWithFiles)" />
      <_BackportsTfms Include="@(_BackportsTfms1->Distinct())" />
    </ItemGroup>
    <PropertyGroup>
      <_BackportsTfms>@(_BackportsTfms)</_BackportsTfms>
    </PropertyGroup>

    <ItemGroup>
      <_PkgRefs Include="$(_DummyPackageReferenceTemplate.Replace('{{PKGNAME}}','%(_ShimmedPackages.Identity)').Replace('{{PKGVER}}','%(_ShimmedPackages.Version)').Replace('{{TFMCOND}}','%(_ShimmedPackages.TfmCond)'))" />
    </ItemGroup>
    <PropertyGroup>
      <_PkgRefs>@(_PkgRefs,'')</_PkgRefs>
    </PropertyGroup>
    
    <WriteLinesToFile File="$(_BackportsTfmsTxt)" Lines="@(_BackportsTfms)" WriteOnlyWhenDifferent="false" Overwrite="true" />
    
    <!-- Generate and restore dummy project -->
    <MakeDir Directories="$(_DummyRestoreProjectDir)" />
    <!-- Make sure it doesn't inherit parent dir.build.* -->
    <WriteLinesToFile Lines="&lt;Project&gt;&lt;/Project&gt;" File="$(_DummyRestoreProjectDir)Directory.Build.props" Overwrite="true" />
    <WriteLinesToFile Lines="&lt;Project&gt;&lt;/Project&gt;" File="$(_DummyRestoreProjectDir)Directory.Build.targets" Overwrite="true" />
    <WriteLinesToFile Lines="$(_DummyRestoreProjectTemplate.Replace('{{TFMS}}', '$(_BackportsTfms)').Replace('{{PKGREF}}', '$(_PkgRefs)'))" File="$(_DummyRestoreProjectPath)" Overwrite="true" />

    <!-- Run a restore -->
    <MSBuild Projects="$(_DummyRestoreProjectPath)" Targets="Restore" />
    
    <!-- Then get reference path -->
    <MSBuild Projects="$(_DummyRestoreProjectPath)"
             Targets="GetReferencesForApiCompatValidatePackage"
             Properties="TargetFramework=%(_BackportsTfms.Identity);
                         BuildProjectReferences=false">
      <Output ItemName="_ApiCompatRefPath" TaskParameter="TargetOutputs" />
    </MSBuild>
    
    <!-- Invoke GenApiCompatDll to figure out the set of comparisons to make -->
    <PropertyGroup>
      <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and '$(OS)' == 'Windows_NT'">.exe</_NativeExecutableExtension>
      <_GenApiCompatExe>%(MMGenApiCompat.RelativeDir)%(FileName)$(_NativeExecutableExtension)</_GenApiCompatExe>
    </PropertyGroup>

    <ItemGroup>
      <_PPArguments Remove="@(_PPArguments)" />
      <_PPArguments Include="$(IntermediateOutputPath)apicompat/" /> <!-- 1: the output directory -->
      <_PPArguments Include="$(_BackportsTfmsTxt)" /> <!-- 2: tfm file -->
      <!-- 3: the paths to the packages to process -->
      <_PPArguments Include="%(_ShimmedPackages.PkgPath)" />
    </ItemGroup>

    <Exec ConsoleToMsBuild="true" LogStandardErrorAsError="true"
      Command="&quot;$(_GenApiCompatExe)&quot; @(_PPArguments->'&quot;%(Identity)&quot;',' ')">
      <Output TaskParameter="ExitCode" PropertyName="_ExitCode" />
      <Output TaskParameter="ConsoleOutput" ItemName="_GenApiCompatOutput" />
    </Exec>

    <Error Text="ShimGen failed" Condition="'$(_ExitCode)' != '0'" />
    
    <!-- Now, we need to parse the GenApiCompat output -->
    <ItemGroup>
      <_GenApiCompatParsed Include="%(_GenApiCompatOutput.Identity)">
        <HiTfm>$([System.String]::Copy('%(Identity)').Split('|')[0])</HiTfm>
        <HiDll>$([System.String]::Copy('%(Identity)').Split('|')[1])</HiDll>
        <LoTfm>$([System.String]::Copy('%(Identity)').Split('|')[2])</LoTfm>
        <LoDll>$([System.String]::Copy('%(Identity)').Split('|')[3])</LoDll>
      </_GenApiCompatParsed>
    </ItemGroup>
    
  </Target>

  <Target Name="_ApiCompatSelectRefPath" DependsOnTargets="_FixReferencePathForValidate" Outputs="|%(_GenApiCompatParsed.Identity)|">
    <PropertyGroup>
      <_HiTfm>%(_GenApiCompatParsed.HiTfm)</_HiTfm>
      <_LoTfm>%(_GenApiCompatParsed.LoTfm)</_LoTfm>
      <_HiRefPath></_HiRefPath>
      <_LoRefPath></_LoRefPath>
      <_HiRefPath Condition="'$(_HiTfm)' == '%(_ApiCompatRefPath.Identity)'">%(_ApiCompatRefPath.ReferencePath)</_HiRefPath>
      <_LoRefPath Condition="'$(_LoTfm)' == '%(_ApiCompatRefPath.Identity)'">%(_ApiCompatRefPath.ReferencePath)</_LoRefPath>
    </PropertyGroup>
    <ItemGroup>
      <_GenApiCompatParsed Update="%(_GenApiCompatParsed.Identity)">
        <HiRefPath>$(_HiRefPath)</HiRefPath>
        <LoRefPath>$(_LoRefPath)</LoRefPath>
      </_GenApiCompatParsed>
    </ItemGroup>
  </Target>

  <Target Name="_ApiCompatFinalizeInputs" DependsOnTargets="_ApiCompatSelectRefPath">
  </Target>
  
  <PropertyGroup>
    <_ApiCompatValidateAssembliesSemaphoreFile>$(IntermediateOutputPath)$(MSBuildThisFileName).apicompat.semaphore</_ApiCompatValidateAssembliesSemaphoreFile>
    <ApiCompatValidateAssembliesDependsOn>CollectApiCompatInputs;$(ApiCompatValidateAssembliesDependsOn);_ApiCompatFinalizeInputs</ApiCompatValidateAssembliesDependsOn>
  </PropertyGroup>
  
  <Target Name="DoApiCompatValidateAssembliesCore"
          AfterTargets="Pack"
          Inputs="@(_GenApiCompatParsed);
                  @(ApiCompatSuppressionFile);
                  $(ApiCompatSuppressionOutputFile)"
          Outputs="$(_ApiCompatValidateAssembliesSemaphoreFile)"
          DependsOnTargets="$(ApiCompatValidateAssembliesDependsOn)">
    <Microsoft.DotNet.ApiCompat.Task.ValidateAssembliesTask
      RoslynAssembliesPath="$(RoslynAssembliesPath)"
      LeftAssemblies="@(_GenApiCompatParsed->'%(LoDll)')"
      RightAssemblies="@(_GenApiCompatParsed->'%(HiDll)')"
      GenerateSuppressionFile="$(ApiCompatGenerateSuppressionFile)"
      PreserveUnnecessarySuppressions="$(ApiCompatPreserveUnnecessarySuppressions)"
      PermitUnnecessarySuppressions="$(ApiCompatPermitUnnecessarySuppressions)"
      SuppressionFiles="@(ApiCompatSuppressionFile)"
      SuppressionOutputFile="$(ApiCompatSuppressionOutputFile)"
      NoWarn="$(NoWarn)"
      RespectInternals="$(ApiCompatRespectInternals)"
      EnableRuleAttributesMustMatch="$(ApiCompatEnableRuleAttributesMustMatch)"
      ExcludeAttributesFiles="@(ApiCompatExcludeAttributesFile)"
      EnableRuleCannotChangeParameterName="$(ApiCompatEnableRuleCannotChangeParameterName)"
      EnableStrictMode="$(ApiCompatStrictMode)"
      LeftAssembliesReferences="@(_GenApiCompatParsed->'%(LoRefPath)')"
      RightAssembliesReferences="@(_GenApiCompatParsed->'%(HiRefPath)')"
      CreateWorkItemPerAssembly="true"
      LeftAssembliesTransformationPattern="@(ApiCompatLeftAssembliesTransformationPattern)"
      RightAssembliesTransformationPattern="@(ApiCompatRightAssembliesTransformationPattern)"
      SemaphoreFile="$(_ApiCompatValidateAssembliesSemaphoreFile)" />
  </Target>

</Project>