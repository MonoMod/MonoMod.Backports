<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <!-- We're not going to be having any of the logic that would use the shared sources, so we'll just not include them -->
    <TargetFrameworks>$(TargetFrameworks);netstandard2.1;netcoreapp2.1</TargetFrameworks>
    <MMSharedSourceFiles>false</MMSharedSourceFiles>
    <MMIncludeUnsafeAlias>true</MMIncludeUnsafeAlias>
    <MMReferenceUtils>false</MMReferenceUtils>
    <MMReferenceBackports>false</MMReferenceBackports>
    <RootNamespace><![CDATA[ ]]></RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <!-- Filter application -->
    <ProjectReference Include="$(MMSourcePath)MonoMod.Backports.Filter\MonoMod.Backports.Filter.csproj" 
                      Reference="false" ReferenceOutputAssembly="false" 
                      OutputItemType="BackportsFilter" Private="false"
                      SetTargetFramework="TargetFramework=net6.0"
                      SkipGetTargetFrameworkProperties="true" />
  </ItemGroup>

  <!-- Because this is imported before Microsoft.Common.CurrentVersion.targets, we need to delay creating these properties -->
  <Target Name="_CreateBackportsFilePathProps">
  <PropertyGroup>
    <_FileOptionsPath>$(IntermediateOutputPath)to_compile.txt</_FileOptionsPath>
    <_ToRemovePath>$(IntermediateOutputPath)to_remove.txt</_ToRemovePath>
  </PropertyGroup>
  </Target>
  
  <Target Name="_WriteFileOptions" DependsOnTargets="_CreateBackportsFilePathProps"
          Inputs="@(Compile)" Outputs="$(_FileOptionsPath)">
    <WriteLinesToFile File="$(_FileOptionsPath)" Overwrite="true" WriteOnlyWhenDifferent="true" Lines="@(Compile)" />
    <ItemGroup>
      <FileWrites Include="$(_FileOptionsPath)" />
    </ItemGroup>
  </Target>

  <Target Name="_RunFilterOnFiles" DependsOnTargets="_WriteFileOptions"
          Inputs="@(BackportsFilter);$(_FileOptionsPath)" Outputs="$(_ToRemovePath)">
    <PropertyGroup>
      <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and '$(OS)' == 'Windows_NT'">.exe</_NativeExecutableExtension>
      <_BackportsFilterBinary>%(BackportsFilter.RelativeDir)%(FileName)$(_NativeExecutableExtension)</_BackportsFilterBinary>
    </PropertyGroup>

    <ItemGroup>
      <_FilterArguments Include="$(_FileOptionsPath)"/>
      <_FilterArguments Include="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)'))" />
      <_FilterArguments Include="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)'))" />
      <_FilterArguments Include="$(_ToRemovePath)" />
    </ItemGroup>
    
    <Exec Command="&quot;$(_BackportsFilterBinary)&quot; filter @(_FilterArguments->'&quot;%(Identity)&quot;',' ')">
      <Output TaskParameter="ExitCode" PropertyName="_FilterExitCode" />
    </Exec>

    <Error Text="Filter failed" Condition="'$(_FilterExitCode)' != '0'" />

    <ItemGroup>
      <FileWrites Include="$(_ToRemovePath)" />
    </ItemGroup>
  </Target>
  
  <!-- Conditionally importing based on TFMs, but automated -->
  <PropertyGroup>
    <CoreCompileDependsOn>FilterTFMRestrictedFiles;$(CoreCompileDependsOn)</CoreCompileDependsOn>
  </PropertyGroup>
  
  <Target Name="FilterTFMRestrictedFiles" DependsOnTargets="_RunFilterOnFiles">
    <ReadLinesFromFile File="$(_ToRemovePath)">
      <Output TaskParameter="Lines" ItemName="_ItemsToFilter" />
    </ReadLinesFromFile>

    <ItemGroup>
      <Compile Remove="@(_ItemsToFilter)" />
    </ItemGroup>
  </Target>

</Project>
